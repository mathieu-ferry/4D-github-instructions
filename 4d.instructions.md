---
applyTo: '**/*.4dm'
---

# 4D Development Guidelines

## Core Principles

- **ALWAYS** use proper 4D syntax and conventions
- **PREFER** explicit type declarations for clarity
- **FOLLOW** 4D naming conventions (methods in PascalCase, variables with $)
- **ENSURE** proper error handling in all code
- **KEEP** code methods tokens if any

## Variables & Types

### Variable Declaration Rules

- **ALL** variables must start with `$`
- **ALWAYS** declare variables with `var $varname: Type`
- **USE** descriptive names: `$userEmail` not `$e`

### Available Types

| Type | Usage | Example |
|------|--------|---------|
| `Integer` | Whole numbers | `var $count: Integer` |
| `Real` | Decimal numbers | `var $price: Real` |
| `Boolean` | True/false values | `var $isValid: Boolean` |
| `Text` | Strings | `var $userName: Text` |
| `Object` | JSON-like objects | `var $user: Object` |
| `Collection` | Arrays | `var $items: Collection` |
| `Date` | Date values | `var $today: Date` |
| `Time` | Time values | `var $now: Time` |
| `Picture` | Images | `var $image: Picture` |
| `Pointer` | References | `var $ptr: Pointer` |
| `Variant` | Unknown/mixed type | `var $data: Variant` |

### Type Declaration Best Practices

```4d
// ✅ GOOD - Explicit declaration
var $userName: Text
$userName:="John Doe"

// ✅ ACCEPTABLE - Direct assignment (type inferred)
var $count:=42

// ❌ AVOID - No declaration
$userName:="John Doe"
```

### Modern Object & Collection Syntax

```4d
// ✅ PREFERRED - Sugar syntax for objects
var $user: Object:={name: "John"; email: "john@example.com"; age: 30}

// ✅ PREFERRED - Sugar syntax for collections
var $items: Collection:=["apple"; "banana"; "orange"]
var $users: Collection:=[{name: "John"; age: 30}; {name: "Jane"; age: 25}]

// ⚠️ USE WHEN KEYS HAVE SPACES OR SPECIAL CHARACTERS
var $config: Object:=New object("api key"; "abc123"; "max-retries"; 3)

// ✅ EMPTY OBJECTS AND COLLECTIONS
var $emptyObject: Object:={}
var $emptyCollection: Collection:=[]
```

#### Sugar Syntax Rules

- **USE `{}` for objects** when all keys are valid JSON identifiers (no spaces, special chars, or starting with numbers)
- **USE `[]` for collections** in all cases
- **FALLBACK to `New object()`** when keys contain spaces, special characters, or start with numbers
- **PREFER sugar syntax** for better readability and modern 4D style

#### Valid vs Invalid Keys for Sugar Syntax

```4d
// ✅ VALID - Use sugar syntax
var $valid: Object:={ \
    name: "John"; \
    email: "test@example.com"; \
    isActive: True; \
    userId: 123 \
}

// ❌ INVALID FOR SUGAR - Use New object()
var $invalid: Object:=New object(
    "first name"; "John";  \       // Space in key
    "user-id"; 123;  \            // Hyphen in key  
    "2ndAddress"; "Street"; \    // Starts with number
    "@handle"; "john_doe" \      // Special character
)
```  

## code tokens

`:Cxxx`, for instance `:C1132` in  `Asserted:C1132()` tokens are used for `Asserted()` commands.

## Control Structures & Loops

### Standard For Loop

```4d
// Basic numeric loop
var $index: Integer
For ($index; 1; $maxValue)
    // Process $index
End for

// Loop with step
For ($index; 0; $maxValue; 2)  // Step by 2
    // Process even indices
End for
```

### Collection Iteration

```4d
// Iterate over collection values
var $item: Variant
var $items: Collection
For each ($item; $items)
    // Process each $item
End for each
```

### Object Property Iteration

```4d
// Iterate over object keys
var $key: Text
var $object: Object
For each ($key; $object)
    var $value:=$object[$key]
    // Process $key and $value
End for each
```

### Conditional Loops

```4d
// While loop
var $continue: Boolean:=True
While ($continue)
    // Process
    $continue:=(someCondition)
End while

// Repeat-Until loop
var $result: Text
Repeat 
    $result:=getUserInput()
Until ($result#"")  // Continue until not empty
```

### Conditional Statements

```4d
// Simple if
If ($condition)
    // Do something
End if

// If-else
If ($condition)
    // Do something
Else 
    // Do something else
End if

// Multiple conditions & Case statement
Case of 
    : ($condition1)
        // Handle 1
    : ($condition2)
        // Handle 2
    Else 
        // Default case
End case
```

## Methods

### Method Structure

- **Location**: `.4dm` files in `Project/Sources/Methods/`
- **Parameters**: Use `#DECLARE($arg1: Type1; $arg2: Type2; ...)`
- **Return**: Use `return` keyword instead of `$0`
- **Naming**: Use PascalCase (e.g., `CalculateTotal`, `ValidateEmail`)

### Method Examples

```4d
// Simple method with parameters (no empty line before #DECLARE)
#DECLARE($name: Text; $age: Integer): Text
var $greeting: Text
$greeting:="Hello "+$name+", you are "+String($age)+" years old"
return $greeting
```

```4d
// Method with object parameter
#DECLARE($user: Object) : Boolean
If ($user.name#"") & ($user.email#"")
    return True
Else 
    return False
End if
```

```4d
// Method with collection processing
#DECLARE($items: Collection) : Real
var $item: Object
var $total: Real:=0
For each ($item; $items)
    $total:=$total+$item.price
End for each
return $total
```

### Error Handling in Methods

```4d
#DECLARE($filePath: Text) : Object
var $result: Object:={success: False; error: ""}

Try
    var $content: Text
    $content:=Document to text($filePath)
    $result.success:=True
    $result.data:=$content
Catch
    $result.error:=Last errors.first().message
End try

return $result
```

## Classes

### Class Structure

- **Location**: `.4dm` files in `Project/Sources/Classes/`
- **Naming**: PascalCase, one class per file
- **File Name**: Must match class name exactly
- **Best Practice**: Declare properties before constructor for type safety and clarity

### Basic Class Example

```4d
// File: Project/Sources/Classes/User.4dm
property name : Text
property email : Text
property createdAt : Date

Class constructor ($name: Text; $email: Text)
This.name:=$name
This.email:=$email
This.createdAt:=Current date

// Regular function
Function getDisplayName() : Text
return This.name+" <"+This.email+">"

// Function with parameters
Function updateEmail($newEmail: Text) : Boolean
If (This.validateEmail($newEmail))
    This.email:=$newEmail
    return True
Else 
    return False
End if

// Private validation method
Function validateEmail($email: Text) : Boolean
return (Position("@"; $email)>0)
```

### Property Declarations

Properties should be declared at the top of the class before the constructor:

```4d
// Declare properties with types
property firstName : Text
property lastName : Text
property age : Integer
property isActive : Boolean
property orders : Collection
property department : cs.DepartmentEntity

Class constructor($firstName : Text; $lastName : Text)
This.firstName:=$firstName
This.lastName:=$lastName
This.age:=0
This.isActive:=True
This.orders:=[]
This.department:=Null
```

### Inheritance

```4d
// File: Project/Sources/Classes/AdminUser.4dm
Class extends User

Class constructor ($name: Text; $email: Text; $permissions: Collection)
Super($name; $email)  // Call parent constructor
This.permissions:=$permissions
This.role:="admin"

Function hasPermission($permission: Text) : Boolean
return (This.permissions.indexOf($permission)>=0)
```

### Computed Properties

```4d
// Read-only computed property
Function get isActive() : Boolean
return (This.lastLogin>(Current date-30))

// Read-write computed property
Function get fullName() : Text
return This.firstName+" "+This.lastName

Function set fullName($value: Text)
var $parts: Collection
$parts:=Split string($value; " ")
If ($parts.length>=2)
    This.firstName:=$parts[0]
    This.lastName:=$parts[1]
End if
```

### Singleton Pattern

```4d
// File: Project/Sources/Classes/ConfigManager.4dm
singleton Class constructor
This.settings:={}

Function getSetting($key: Text) : Variant
return This.settings[$key]

Function setSetting($key: Text; $value: Variant)
This.settings[$key]:=$value

// Usage in other code:
// var $config:=cs.ConfigManager.me
// $config.setSetting("theme"; "dark")
```

## Testing

- **Location**: `.4dm` files in `Project/Sources/Methods/`
- **Naming**: `test_` prefix (e.g., `test_UserValidation.4dm`)
- **Organization**: Group in "tests" folder via `folders.json`
- **Running tests**: See `4dtest.md.instructions.md`

```4d
// Example test
var $user: cs.User:=cs.User.new("John"; "john@example.com")
ASSERT($user.validateEmail($user.email); "Valid email should pass")

// Test error handling
Try
    var $invalid: cs.User:=cs.User.new(""; "test@example.com")
    ASSERT(False; "Empty name should throw error")
Catch
    ASSERT(True; "Empty name correctly throws error")
End try
```

## Project Structure & Organization

### File Organization

```text
Project/
├── Sources/
│   ├── Classes/           # Class definitions (.4dm)
│   ├── Methods/           # Standalone methods (.4dm)
│   ├── DatabaseMethods/   # Database event methods
│   ├── Forms/             # Forms and UI
│   ├── TableForms/        # Table-specific forms
│   └── folders.json       # Defines method/class grouping
```

### Naming Conventions

| Element | Convention | Example |
|---------|------------|---------|
| Methods | PascalCase | `CalculateTotal`, `SendEmail` |
| Classes | PascalCase | `User`, `OrderManager` |
| Variables | camelCase with $ | `$userName`, `$totalAmount` |
| Test Methods | test_ prefix | `test_UserCreation` |

## Common Patterns & Best Practices

### Collection Operations

```4d
// Filtering, mapping, sorting
var $adults: Collection:=$users.query("age >= 18")
var $names: Collection:=$users.extract("name")
$users:=$users.orderBy("age desc")
```

### Error Handling Patterns

```4d
// Standard error handling
#DECLARE($data: Object) : Object
var $result:={success: False; data: Null; error: ""}

Try
    // Validate input
    If ($data=Null)
        throw "Input data is required"
    End if
    
    // Process data
    var $processedData: Object:=processData($data)
    
    $result.success:=True
    $result.data:=$processedData
    
Catch
    $result.errors:=Last errors
End try

return $result
```

### Database Operations

```4d
// Entity selection operations
var $employees: cs.EmployeeSelection:=ds.Employee.all()
var $activeEmployees: cs.EmployeeSelection:=$employees.query("active = true")

// Creating new entity
var $newEmployee: cs.EmployeeEntity:=ds.Employee.new()
$newEmployee.name:="John Doe"
$newEmployee.email:="john@company.com"
$newEmployee.save()

// Updating entity
var $employee: cs.EmployeeEntity:=ds.Employee.get(123)
If ($employee#Null)
    $employee.salary:=$employee.salary*1.1
    $employee.save()
End if
```

### File & Folder Management

#### Resources Folder Location

**CRITICAL**: 4D uses the **database-level** `Resources` folder, NOT `Project/Resources/`.

```
4D-Demo-Tasks-AI/                    ← Database root
├── Resources/                        ← ✅ CORRECT location for resources
│   ├── data.json                    
│   ├── config.xml
│   └── images/
├── Project/
│   └── Sources/
└── Data/
```

❌ **WRONG**: `Project/Resources/` - Files here won't be found by 4D
✅ **CORRECT**: `Resources/` at database root level

#### Accessing Files

**ALWAYS** use the modern `File()` and `Folder()` classes, NOT legacy commands like `Document to text`.

```4d
// ✅ CORRECT - Using Folder constant
var $fileContent: Text
$fileContent:=Folder(fk resources folder).file("data.json").getText()

// ✅ CORRECT - Reading JSON file
var $data: Collection
$data:=JSON Parse(Folder(fk resources folder).file("employees.json").getText())

// ✅ CORRECT - Writing to file
var $config: Object:={apiKey: "xyz"; timeout: 30}
Folder(fk resources folder).file("config.json").setText(JSON Stringify($config))

// ❌ WRONG - Using legacy commands
$fileContent:=Document to text(Get 4D folder(Current resources folder)+"data.json")

// ❌ WRONG - Using wrong path notation
$fileContent:=File("/RESOURCES/data.json").getText()
```

#### Common Folder Constants

| Constant | Description | Usage |
|----------|-------------|-------|
| `fk resources folder` | Resources folder | Static files (JSON, XML, images) |
| `fk database folder` | Database root | Main database directory |
| `fk data folder` | Data folder | Data files (.4DD) |
| `fk logs folder` | Logs folder | Application logs |
| `fk backup folder` | Backup folder | Database backups |

#### File Operations

```4d
// Check if file exists
var $file: 4D.File
$file:=Folder(fk resources folder).file("config.json")
If ($file.exists)
    var $content: Text:=$file.getText()
End if

// Create folder if needed
var $folder: 4D.Folder
$folder:=Folder(fk database folder).folder("exports")
If (Not($folder.exists))
    $folder.create()
End if

// List files in folder
var $files: Collection
$files:=Folder(fk resources folder).files()
For each ($file; $files)
    ALERT($file.name+" - "+String($file.size)+" bytes")
End for each

// Copy file
var $source: 4D.File:=Folder(fk resources folder).file("template.json")
var $destination: 4D.Folder:=Folder(fk database folder).folder("temp")
$source.copyTo($destination; "config.json")
```

#### Best Practices

1. **ALWAYS** use `Folder(fk resources folder)` to access resources
2. **CHECK** if file exists before reading: `$file.exists`
3. **USE** `.getText()` for text files, `.getContent()` for binary
4. **PREFER** JSON over XML for data files when possible
5. **HANDLE** errors when reading/writing files with Try/Catch
6. **NEVER** hardcode absolute paths - use folder constants

```4d
// Example: Safe file loading with error handling
#DECLARE() : Object
var $result: Object:={success: False; data: Null; error: ""}

Try
    var $file: 4D.File:=Folder(fk resources folder).file("config.json")
    
    If (Not($file.exists))
        throw "Configuration file not found"
    End if
    
    var $content: Text:=$file.getText()
    $result.data:=JSON Parse($content)
    $result.success:=True
    
Catch
    $result.error:=Last errors.first().message
End try

return $result
```

## Code Quality Checklist

- ✅ All variables declared with types (`var $name: Type`)
- ✅ Sugar syntax `{}` for objects, `[]` for collections (fallback to `New object()` for special keys)
- ✅ Methods start with `#DECLARE` with typed parameters
- ✅ Proper error handling with Try/Catch where needed
- ✅ Meaningful, descriptive names (PascalCase methods, $camelCase variables)
- ✅ Tests cover success, failure, and edge cases  

## Data Generation & Import

### Overview

4D provides the `fromCollection()` method for bulk importing data from JSON collections into database tables. This approach is ideal for:
- Initial database seeding with sample data
- Importing data from external sources
- Testing and development environments
- Data migration scenarios

### The Two-Phase Import Strategy

When importing data with relations between tables, use a **two-phase strategy**:

#### Phase 1: Import all entities (without relations)
Import all base records first, letting 4D auto-generate primary keys (UUIDs). Import order doesn't matter - both "parent" and "child" tables can be imported together since IDs are auto-generated.

#### Phase 2: Set relations for each table
For each table that has relations, iterate through the data and set the relations using helper fields from the JSON. You need **one pass per table** that has relations, not one pass per relation.

**Example**: For Employees ↔ Departments with Manager:
- Phase 1: Import Departments, then Employees (both get IDs)
- Phase 2a: Set Employees → Department relations
- Phase 2b: Set Departments → Manager (Employee) relations

### Complete Implementation Example

```4d
// InitializeData.4dm
// Demonstrates the two-phase import strategy with proper type handling

#DECLARE()

var $departmentsJSON; $employeesJSON : Text
var $departments; $employees : Collection
var $dept : cs.DepartmentsEntity
var $empEntity : cs.EmployeesEntity
var $emp : cs.EmployeesEntity
var $empData; $deptData : Object

// Clear existing data with user confirmation
CONFIRM("This will delete all existing data and reload from JSON files. Continue?"; "Yes"; "No")
If (OK=1)
    // Delete existing records
    ds.Employees.all().drop()
    ds.Departments.all().drop()
    
    // Load JSON files from Resources folder
    $departmentsJSON:=Folder(fk resources folder).file("departments.json").getText()
    $employeesJSON:=Folder(fk resources folder).file("employees.json").getText()
    
    $departments:=JSON Parse($departmentsJSON)
    $employees:=JSON Parse($employeesJSON)
    
    // ============================================
    // PHASE 1: Import all entities (get IDs generated)
    // ============================================
    Try
        ds.Departments.fromCollection($departments)
        ALERT("Imported "+String($departments.length)+" departments")
    Catch
        ALERT("Error importing departments: "+Last errors.first().message)
    End try
    
    Try
        ds.Employees.fromCollection($employees)
        ALERT("Imported "+String($employees.length)+" employees")
    Catch
        ALERT("Error importing employees: "+Last errors.first().message)
    End try 
    
    // ============================================
    // PHASE 2: Set relations for each table
    // ============================================
    
    // 2a. Set Employee → Department relations
    For each ($empData; $employees)
        If ($empData.departmentName#Null)
            // Find the employee entity by unique fields
            $empEntity:=ds.Employees.query("Firstname = :1 AND Name = :2"; \
                $empData.Firstname; $empData.Name).first()
            
            If ($empEntity#Null)
                // Find and set the department relation
                $dept:=ds.Departments.query("Name = :1"; $empData.departmentName).first()
                If ($dept#Null)
                    $empEntity.Department:=$dept
                    $empEntity.save()
                End if 
            End if 
        End if 
    End for each 
    
    ALERT("Linked employees to departments")
    
    // 2b. Set Department → Manager (Employee) relations
    For each ($deptData; $departments)
        // Find the department entity
        $dept:=ds.Departments.query("Name = :1"; $deptData.Name).first()
        
        If ($dept#Null)
            If ($deptData.managerFirstname#Null) && ($deptData.managerLastname#Null)
                // Find the employee to set as manager
                $emp:=ds.Employees.query("Firstname = :1 AND Name = :2"; \
                    $deptData.managerFirstname; $deptData.managerLastname).first()
                
                If ($emp#Null)
                    $dept.Manager:=$emp
                    $dept.save()
                End if 
            End if 
        End if 
    End for each 
    
    ALERT("Data initialization complete!")
End if
```

### JSON Data Structure

#### Key Principles

1. **Field Name Matching**: JSON property names must **exactly match** catalog field names (case-sensitive)
2. **Helper Fields**: Include non-table fields in JSON for relation mapping (e.g., `departmentName`, `managerFirstname`)
3. **Auto-Generated Fields**: Omit UUID primary keys - 4D generates them automatically
4. **Required Fields**: Always include fields marked as `not_null` in catalog

#### Example: departments.json

```json
[
    {
        "Name": "Engineering",
        "Description": "Software development and technical architecture",
        "managerFirstname": "Alice",
        "managerLastname": "Johnson"
    },
    {
        "Name": "Marketing",
        "Description": "Brand management and customer engagement",
        "managerFirstname": "Bob",
        "managerLastname": "Smith"
    }
]
```

**Note**: 
- `Name` and `Description` match catalog fields exactly
- `managerFirstname` and `managerLastname` are **helper fields** (not in catalog) for relation mapping
- `ID` field is omitted - 4D auto-generates UUIDs

#### Example: employees.json

```json
[
    {
        "Firstname": "Alice",
        "Name": "Johnson",
        "departmentName": "Engineering"
    },
    {
        "Firstname": "Bob",
        "Name": "Smith",
        "departmentName": "Marketing"
    }
]
```

**Note**:
- `Firstname` and `Name` match catalog fields (note capitalization!)
- `departmentName` is a **helper field** for relation mapping
- `Department_ID` field is omitted - set via relation in Pass 3

### Critical Type System Rules

#### Object vs Entity Types

**CRITICAL**: Understand the distinction between JSON objects and database entities:

```4d
// ✅ CORRECT - Separate types for JSON and entities
var $empData : Object          // JSON object - can have ANY properties
var $empEntity : cs.EmployeesEntity  // Database entity - ONLY table fields

For each ($empData; $employees)  // Iterate JSON collection
    // Access helper field from JSON object
    If ($empData.departmentName#Null)  // ✅ OK - JSON can have any property
        
        // Query for entity
        $empEntity:=ds.Employees.query("Name = :1"; $empData.Name).first()
        
        // Set entity relation
        $empEntity.Department:=$dept  // ✅ OK - Department is a relation field
        $empEntity.save()
    End if
End for each
```

```4d
// ❌ WRONG - Using entity type for JSON iteration
var $emp : cs.EmployeesEntity

For each ($emp; $employees)  // $employees is JSON collection!
    If ($emp.departmentName#Null)  // ❌ ERROR - Entity can't have this property
        // departmentName doesn't exist in Employees table
    End if
End for each
```

**Rules**:
- **JSON objects** (`Object` type) can have any properties, including helper fields
- **Entity objects** (`cs.TableNameEntity` type) can ONLY access table fields and relations
- **Use Object type** when iterating over JSON collections from `JSON Parse()`
- **Use Entity type** when working with database records from `ds.TableName.query()`

### fromCollection() API Usage

#### Basic Usage

```4d
// Import collection directly into table
var $data : Collection
$data:=JSON Parse(Folder(fk resources folder).file("data.json").getText())

Try
    ds.TableName.fromCollection($data)
    // Success - records are created
Catch
    // Handle errors
    var $error : Text:=Last errors.first().message
    ALERT("Import failed: "+$error)
End try
```

#### Important fromCollection() Behaviors

1. **Return Value**: Returns an `Entity Selection`, NOT a status object
   ```4d
   // ✅ CORRECT - fromCollection returns entity selection
   var $imported : cs.EmployeesSelection
   $imported:=ds.Employees.fromCollection($data)
   
   // ❌ WRONG - No .success property exists
   var $result : Object
   $result:=ds.Employees.fromCollection($data)
   If ($result.success)  // ERROR: success property doesn't exist
   ```

2. **Error Handling**: Use `Try/Catch`, not status checking
   ```4d
   // ✅ CORRECT - Use Try/Catch
   Try
       ds.Employees.fromCollection($employees)
   Catch
       var $errors : Collection:=Last errors
       // Handle error
   End try
   ```

3. **Auto-Generated Fields**: Primary keys are generated automatically if configured in catalog
   ```xml
   <!-- In catalog.4DCatalog -->
   <field name="ID" uuid="..." type="10" unique="true" autogenerate="true" 
          store_as_UUID="true" not_null="true"/>
   ```

4. **Field Matching**: JSON properties must match catalog field names exactly (case-sensitive)

### Common Pitfalls & Solutions

#### Pitfall 1: Case Sensitivity in Field Names

```json
// ❌ WRONG - Lowercase field names don't match catalog
{
    "name": "John",
    "firstname": "Doe"
}

// ✅ CORRECT - Match catalog field names exactly
{
    "Name": "John",
    "Firstname": "Doe"
}
```

**Error**: "Mandatory field is Null" - when case doesn't match, 4D can't map the data.

#### Pitfall 2: Wrong Resources Folder Location

```4d
// ❌ WRONG - File not in Resources folder
$content:=Folder(fk database folder).folder("Project").folder("Resources").file("data.json").getText()

// ✅ CORRECT - Use Resources folder constant
$content:=Folder(fk resources folder).file("data.json").getText()
```

**Error**: File not found - `Project/Resources/` doesn't exist in 4D structure.

#### Pitfall 3: Setting Relations During fromCollection()

```json
// ❌ WRONG - Trying to set relation via ID during import
{
    "Name": "John",
    "Department_ID": "550e8400-e29b-41d4-a716-446655440000"
}
```

**Problem**: UUIDs from JSON won't match auto-generated UUIDs in database.

**Solution**: Use helper fields and set relations in Pass 3/4:

```json
// ✅ CORRECT - Use helper field for later mapping
{
    "Name": "John",
    "departmentName": "Engineering"
}
```

#### Pitfall 4: Mixing JSON and Entity Types

```4d
// ❌ WRONG - Entity type accessing JSON properties
var $emp : cs.EmployeesEntity
For each ($emp; $jsonCollection)
    If ($emp.departmentName#Null)  // ERROR: Entity can't have this property
```

**Error**: "The property departmentName is unexpected"

**Solution**: Use `Object` type for JSON, `Entity` type for database records:

```4d
// ✅ CORRECT - Object type for JSON iteration
var $empData : Object
var $empEntity : cs.EmployeesEntity

For each ($empData; $jsonCollection)
    If ($empData.departmentName#Null)  // OK: Object can have any property
        $empEntity:=ds.Employees.query("Name = :1"; $empData.Name).first()
        // Now work with $empEntity for database operations
    End if
End for each
```

### Best Practices Summary

1. **File Location**: Always place JSON files in database-level `Resources/` folder
2. **File Access**: Use `Folder(fk resources folder).file()` - never hardcode paths
3. **Field Names**: Match catalog field names exactly (case-sensitive)
4. **Helper Fields**: Include non-table fields in JSON for relation mapping
5. **Type Separation**: Use `Object` for JSON, `Entity` types for database records
6. **Import Strategy**: Phase 1: import all entities; Phase 2: set relations per table
7. **Error Handling**: Use `Try/Catch` blocks, check `Last errors` collection
8. **UUID Keys**: Let 4D auto-generate, never hardcode in JSON
9. **Validation**: Test with small datasets first, verify relations are correct
10. **Confirmation**: Always confirm before clearing existing data

### Testing Import Methods

```4d
// Test import with validation
#DECLARE() : Object
var $result : Object:={success: True; stats: {}; errors: []}

Try
    // Import
    ds.Employees.fromCollection($data)
    
    // Validate
    var $count : Integer:=ds.Employees.all().length
    $result.stats.imported:=$count
    
    // Check relations
    var $withDept : Integer:=ds.Employees.query("Department # Null").length
    $result.stats.withRelations:=$withDept
    
    If ($withDept<$count)
        $result.errors.push("Some employees not linked to departments")
    End if
    
Catch
    $result.success:=False
    $result.errors:=Last errors
End try

return $result
```

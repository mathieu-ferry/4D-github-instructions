# 4D Catalog File Editing Guide

## Overview
The `catalog.4DCatalog` file is an XML file that defines the complete database structure for a 4D application. It must conform to the DTD specification: `http://www.4d.com/dtd/2007/base.dtd`

**Based on analysis of 4D depot repositories** - this guide follows proven patterns from production 4D applications.

## File Structure

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE base SYSTEM "http://www.4d.com/dtd/2007/base.dtd" >
<base name="DatabaseName" uuid="E20114E6CC684175B1B0A67001DD31D6" collation_locale="en">
    <schema name="DEFAULT_SCHEMA"/>
    <!-- Tables -->
    <!-- Relations -->
    <!-- Indexes -->
    <base_extra>
        <journal_file journal_file_enabled="true|false"/>
    </base_extra>
</base>
```

⚠️ **IMPORTANT**: All `uuid` attributes must contain **actual UUID values** (32 hexadecimal characters), not placeholder text. Generate UUIDs using `uuidgen` command or online tools. Examples of real UUID formats:
- With hyphens: `E20114E6-CC68-4175-B1B0-A67001DD31D6`
- Without hyphens: `E20114E6CC684175B1B0A67001DD31D6`
- Both formats are valid in 4D catalogs

## Tables

### Basic Table Structure
```xml
<table name="tableName" uuid="D51B26D316C37D4BA9AB081E94BAF6C3" id="1">
    <!-- Fields -->
    <primary_key field_name="ID" field_uuid="9B79A7051949394E8001F9367CE27A4A"/>
</table>
```

### Important Rules for Tables:
1. Each table MUST have a unique `uuid` attribute (actual UUID value)
2. Each table MUST have a sequential `id` attribute (starting from 1)
3. Each table MUST have a `<primary_key>` element if journaling is enabled
4. Table names should match the dataClass name from the model

## Fields

### Field Types
| Type Code | 4D Type | Notes |
|-----------|---------|-------|
| 1 | Boolean | |
| 3 | Word (16-bit integer) | |
| 4 | Long (32-bit integer) | Used for auto-increment IDs |
| 5 | Long Long (64-bit integer) | Used for timestamps, large numbers |
| 6 | Number (float/real) | |
| 8 | Date | |
| 9 | Duration (time) | |
| 10 | String/Text/UUID | Use for both limited and unlimited text |
| 12 | Picture/Image | |
| 13 | BLOB | |
| 21 | Object/BLOB | Use for objects, vectors, and large data |

### Field Syntax Patterns

**UUID Primary Key (RECOMMENDED for modern apps):**
```xml
<field name="ID" uuid="F1E2D3C4B5A6478990A1B2C3D4E5F679" type="10" unique="true" autogenerate="true" store_as_UUID="true" not_null="true" id="1"/>
```

**Integer Primary Key (legacy/simple apps):**
```xml
<field name="ID" uuid="C87D853EACF4CB45AAF7FF4A26F62345" type="4" unique="true" autosequence="true" never_null="true" id="1"/>
```

**String field with length limit:**
```xml
<field name="name" uuid="F2E3D4C5B6A7478990A1B2C3D4E5F680" type="10" limiting_length="255" id="2"/>
```

**Text field (unlimited string):**
```xml
<field name="description" uuid="9E628B5A85E25D47815547CC8A6D9582" type="10" id="3"/>
```
⚠️ **CRITICAL**: Text fields should be type 10 WITHOUT `limiting_length` attribute. DO NOT use type 11.

**Vector field (for AI embeddings):**
```xml
<field name="embedding" uuid="6F663F394E0D457E9A6AA08CC64A1D7E" type="21" blob_switch_size="2147483647" id="4">
    <field_extra class_id="4D.Vector"/>
</field>
```

**Object/BLOB field:**
```xml
<field name="settings" uuid="0198C6A5AD9F789FA747A9825A83397A" type="21" blob_switch_size="2147483647" never_null="true" id="5"/>
```

**Relation/Foreign key field (UUID):**
```xml
<field name="category_id" uuid="D7AC4883E2CB43D593ACC296B19D5716" type="10" store_as_UUID="true" id="6"/>
```

**Relation/Foreign key field (Integer):**
```xml
<field name="categoryID" uuid="6AC833017FFB4887986A7E7399150CD5" type="4" id="7"/>
```

### Field Attributes Reference
- `name`: Field name (required)
- `uuid`: Unique identifier (required)
- `type`: Field type code (required)
- `id`: Sequential field number within table (required)
- `limiting_length`: Maximum length for strings (e.g., "255")
- `unique`: "true" for unique values
- `autogenerate`: "true" for auto-generated UUID values
- `autosequence`: "true" for auto-increment integer values
- `store_as_UUID`: "true" for UUID storage format (use with type="10")
- `not_null`: "true" to prevent NULL values (use with autogenerate)
- `never_null`: "true" to prevent NULL values (standard for most fields)
- `blob_switch_size`: Maximum BLOB size, typically "2147483647" for large objects

### Field ID Numbering
- Field IDs must be sequential starting from 1
- If you skip an ID (e.g., field removed), you can leave gaps
- Example: id="1", id="2", id="3", id="5" (skipped 4)

### When to Use never_null vs not_null
- **`never_null="true"`**: Standard practice for most fields (per 4D depot examples)
- **`not_null="true"`**: Use specifically with UUID primary keys that have `autogenerate="true"`
- Both prevent NULL values, but usage depends on field type and auto-generation

## Primary Keys

Every table with journaling enabled MUST have a primary key defined:

```xml
<primary_key field_name="ID" field_uuid="FIELD_UUID"/>
```

- Must reference an existing field in the table
- The `field_uuid` must match the UUID of the field being used as primary key
- Typically placed after all field definitions, before `<table_extra>`

## Relations

Relations define foreign key relationships between tables.

### Relation Structure (VERIFIED from 4d-depot repositories)

⚠️ **CRITICAL ATTRIBUTES**: Relations must have these exact attributes to avoid XML validation errors:

```xml
<relation uuid="UNIQUE_UUID" 
          name_Nto1="relatedTable" 
          name_1toN="inverseRelationName" 
          auto_load_Nto1="false" 
          auto_load_1toN="false" 
          foreign_key="false" 
          state="1">
    <related_field kind="source">
        <field_ref uuid="FOREIGN_KEY_UUID" name="foreignKeyField">
            <table_ref uuid="SOURCE_TABLE_UUID" name="sourceTable"/>
        </field_ref>
    </related_field>
    <related_field kind="destination">
        <field_ref uuid="PRIMARY_KEY_UUID" name="ID">
            <table_ref uuid="DEST_TABLE_UUID" name="destinationTable"/>
        </field_ref>
    </related_field>
</relation>
```

### Required Relation Attributes (Lessons Learned)

1. **`auto_load_Nto1="false"`** - Controls N-to-1 auto-loading (REQUIRED)
2. **`auto_load_1toN="false"`** - Controls 1-to-N auto-loading (REQUIRED)
3. **`foreign_key="false"`** - Foreign key constraint flag (REQUIRED, always "false")
4. **`state="1"`** - Relation state (REQUIRED, numeric value without quotes)

❌ **INVALID Attributes** (will cause "XML structure elements definition is damaged" error):
- `auto_delete` - Not a valid attribute
- `path` - Not a valid attribute  
- `foreign_key="automatic"` - Must be "false", not "automatic"
- Missing `auto_load_Nto1` or `auto_load_1toN`

### Optional Relation Extra
The `<relation_extra>` element is optional but recommended for structure editor metadata:

```xml
<relation_extra entry_wildchar="false" entry_create="false" choice_field="0" entry_autofill="false">
    <editor_relation_info via_point_x="-1" via_point_y="-1" prefers_left="false" smartlink="true">
        <color red="255" green="255" blue="255" alpha="0"/>
    </editor_relation_info>
</relation_extra>
```

### Relation Naming Convention
- `name_Nto1`: Name for the N→1 direction (many-to-one, typically singular)
- `name_1toN`: Name for the 1→N direction (one-to-many, typically plural or collection name)

### Complete Example: Employees → Departments
```xml
<!-- 1. Add foreign key field to Employees table -->
<field name="Department_ID" uuid="F4E5D6C7-B8A9-4789-90A1-B2C3D4E5F684" 
       type="10" store_as_UUID="true" id="4"/>

<!-- 2. Create index for foreign key (performance) -->
<index kind="regular" uuid="R1E2L3A4-T5I6-4789-90R1-E2L3A4T5I685" type="7">
    <field_ref uuid="F4E5D6C7-B8A9-4789-90A1-B2C3D4E5F684" name="Department_ID">
        <table_ref uuid="A1B2C3D4-E5F6-4788-90A1-B2C3D4E5F678" name="Employees"/>
    </field_ref>
</index>

<!-- 3. Define the relation -->
<relation uuid="R2E3L4A5-T6I7-4789-90R2-E3L4A5T6I686" 
          name_Nto1="Department" 
          name_1toN="Employees" 
          auto_load_Nto1="false" 
          auto_load_1toN="false" 
          foreign_key="false" 
          state="1">
    <related_field kind="source">
        <field_ref uuid="F4E5D6C7-B8A9-4789-90A1-B2C3D4E5F684" name="Department_ID">
            <table_ref uuid="A1B2C3D4-E5F6-4788-90A1-B2C3D4E5F678" name="Employees"/>
        </field_ref>
    </related_field>
    <related_field kind="destination">
        <field_ref uuid="D2E3F4A5-B6C7-4789-90D2-E3F4A5B6C679" name="ID">
            <table_ref uuid="D1E2F3A4-B5C6-4789-90D1-E2F3A4B5C678" name="Departments"/>
        </field_ref>
    </related_field>
</relation>
```

**Usage in ORDA code:**
```4d
// N-to-1: Get employee's department
$department:=$employee.Department

// 1-to-N: Get all employees in a department
$employees:=$department.Employees
```

### Example: Order → Customer (Integer IDs)
```xml
<relation uuid="REL_UUID" 
          name_Nto1="customer" 
          name_1toN="orders" 
          auto_load_Nto1="false" 
          auto_load_1toN="false" 
          foreign_key="false" 
          state="1">
    <related_field kind="source">
        <field_ref uuid="CUSTOMERID_UUID" name="customerID">
            <table_ref uuid="ORDER_TABLE_UUID" name="Order"/>
        </field_ref>
    </related_field>
    <related_field kind="destination">
        <field_ref uuid="ID_UUID" name="ID">
            <table_ref uuid="CUSTOMER_TABLE_UUID" name="Customer"/>
        </field_ref>
    </related_field>
</relation>
```

## Indexes

Indexes improve query performance. **CRITICAL: Every primary key field MUST have a corresponding index.**

### Index Structure
```xml
<index kind="regular" unique_keys="true" uuid="UNIQUE_UUID" type="7">
    <field_ref uuid="FIELD_UUID" name="fieldName">
        <table_ref uuid="TABLE_UUID" name="tableName"/>
    </field_ref>
</index>
```

### Index Types (per 4D depot standards)
- `type="7"`: B-tree index (MOST COMMON - use for most fields including primary keys)
- `type="1"`: Cluster index (use for primary keys on very large tables)
- `type="3"`: Keywords index (use for full-text search on text fields)

### Index Attributes
- `kind`: Always "regular"
- `unique_keys`: "true" for unique indexes (required for primary keys), omit or "false" for standard
- `uuid`: Unique identifier (generate new UUID for each index)
- `type`: Index type (typically 7)

### When to Create Indexes
1. **Primary keys**: ALWAYS indexed with `unique_keys="true"` and `type="7"`
2. **Foreign keys**: Index all foreign key fields for relation performance
3. **Unique fields**: Fields with unique constraint need `unique_keys="true"`
4. **Frequently searched fields**: Fields used in WHERE clauses

### Example: Primary Key Index
```xml
<index kind="regular" unique_keys="true" uuid="INDEX-UUID" type="7">
    <field_ref uuid="ID-FIELD-UUID" name="ID">
        <table_ref uuid="TABLE-UUID" name="Employee"/>
    </field_ref>
</index>
```

### Example: Foreign Key Index
```xml
<index kind="regular" uuid="INDEX-UUID" type="7">
    <field_ref uuid="CATEGORY-ID-FIELD-UUID" name="category_id">
        <table_ref uuid="TABLE-UUID" name="Product"/>
    </field_ref>
</index>
```

## Common Issues and Solutions

### 1. XML Structure Error: "Impossible to import the structure"

**Root Cause**: Invalid or missing relation attributes.

**Required relation attributes**:
- `auto_load_Nto1="false"`
- `auto_load_1toN="false"`
- `foreign_key="false"` (NOT "automatic")
- `state="1"`

**Invalid attributes** (cause errors): `path`, `auto_delete`

### 2. Fields Disappearing on Reload

**Causes**: Text fields as type 11 (should be type 10), missing primary key, invalid UUID.

### 3. Primary Key Errors

**Solution**: Add `<primary_key field_name="ID" field_uuid="FIELD_UUID"/>` for each table.

### 4. Relation Issues

Verify: All four required attributes present, UUIDs match actual fields, no invalid attributes.

## Best Practices

1. **UUIDs**: Generate unique UUIDs for all elements, never reuse
2. **Field IDs**: Sequential starting at 1 per table
3. **Naming**: camelCase for fields (`firstName`), PascalCase for tables (`Customer`)
4. **Editing workflow**: Add fields incrementally (1-3 at a time), verify after each batch
5. **Backup**: Always backup catalog before manual editing

## Clearing Cache

```bash
rm -rf "Project/DerivedData/[0-9]*"
```

## Migration Notes (Qodly → 4D)

| Qodly Type | 4D Type | Notes |
|------------|---------|-------|
| long | type="4" | |
| string | type="10" limiting_length="255" | |
| text | type="10" (no limiting_length) | ⚠️ NOT type 11! |
| date | type="8" | |
| duration | type="9" | |
| number | type="6" | |
| bool | type="1" | |
| blob | type="13" | |
| image | type="12" | |

**Include**: `kind: "storage"` attributes as fields, foreign key fields for relations  
**Exclude**: `relatedEntity`, `relatedEntities`, computed/alias attributes

## Example: Complete Table Definition

```xml
<!-- Modern approach with UUID primary key -->
<table name="Employee" uuid="AAAAAAAA-AAAA-AAAA-AAAA-AAAAAAAAAAAA" id="1">
    <field name="ID" uuid="BBBBBBBB-BBBB-BBBB-BBBB-BBBBBBBBBBBB" type="10" unique="true" autogenerate="true" store_as_UUID="true" not_null="true" id="1"/>
    <field name="Name" uuid="CCCCCCCC-CCCC-CCCC-CCCC-CCCCCCCCCCCC" type="10" limiting_length="255" id="2"/>
    <field name="Firstname" uuid="DDDDDDDD-DDDD-DDDD-DDDD-DDDDDDDDDDDD" type="10" limiting_length="255" id="3"/>
    <field name="email" uuid="EEEEEEEE-EEEE-EEEE-EEEE-EEEEEEEEEEEE" type="10" limiting_length="255" id="4"/>
    <field name="notes" uuid="FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF" type="10" id="5"/>
    <field name="birthDate" uuid="00000000-0000-0000-0000-000000000001" type="8" id="6"/>
    <field name="isActive" uuid="00000000-0000-0000-0000-000000000002" type="1" never_null="true" id="7"/>
    <field name="department_id" uuid="00000000-0000-0000-0000-000000000003" type="10" store_as_UUID="true" id="8"/>
    <primary_key field_name="ID" field_uuid="BBBBBBBB-BBBB-BBBB-BBBB-BBBBBBBBBBBB"/>
</table>

<!-- Required index for primary key -->
<index kind="regular" unique_keys="true" uuid="11111111-1111-1111-1111-111111111111" type="7">
    <field_ref uuid="BBBBBBBB-BBBB-BBBB-BBBB-BBBBBBBBBBBB" name="ID">
        <table_ref uuid="AAAAAAAA-AAAA-AAAA-AAAA-AAAAAAAAAAAA" name="Employee"/>
    </field_ref>
</index>

<!-- Optional: Index for foreign key -->
<index kind="regular" uuid="22222222-2222-2222-2222-222222222222" type="7">
    <field_ref uuid="00000000-0000-0000-0000-000000000003" name="department_id">
        <table_ref uuid="AAAAAAAA-AAAA-AAAA-AAAA-AAAAAAAAAAAA" name="Employee"/>
    </field_ref>
</index>
```

```xml
<!-- Legacy approach with integer primary key -->
<table name="Customer" uuid="AAAAAAAA-AAAA-AAAA-AAAA-AAAAAAAAAAAA" id="1">
    <field name="ID" uuid="BBBBBBBB-BBBB-BBBB-BBBB-BBBBBBBBBBBB" type="4" unique="true" autosequence="true" never_null="true" id="1"/>
    <field name="firstName" uuid="CCCCCCCC-CCCC-CCCC-CCCC-CCCCCCCCCCCC" type="10" limiting_length="255" id="2"/>
    <field name="lastName" uuid="DDDDDDDD-DDDD-DDDD-DDDD-DDDDDDDDDDDD" type="10" limiting_length="255" id="3"/>
    <field name="email" uuid="EEEEEEEE-EEEE-EEEE-EEEE-EEEEEEEEEEEE" type="10" limiting_length="255" id="4"/>
    <field name="notes" uuid="FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF" type="10" id="5"/>
    <field name="birthDate" uuid="00000000-0000-0000-0000-000000000001" type="8" id="6"/>
    <field name="isActive" uuid="00000000-0000-0000-0000-000000000002" type="1" never_null="true" id="7"/>
    <field name="categoryID" uuid="00000000-0000-0000-0000-000000000003" type="4" id="8"/>
    <primary_key field_name="ID" field_uuid="BBBBBBBB-BBBB-BBBB-BBBB-BBBBBBBBBBBB"/>
</table>

<!-- Required index for primary key -->
<index kind="regular" unique_keys="true" uuid="11111111-1111-1111-1111-111111111111" type="7">
    <field_ref uuid="BBBBBBBB-BBBB-BBBB-BBBB-BBBBBBBBBBBB" name="ID">
        <table_ref uuid="AAAAAAAA-AAAA-AAAA-AAAA-AAAAAAAAAAAA" name="Customer"/>
    </field_ref>
</index>
```

## Validation Checklist

- [ ] All elements have unique UUIDs
- [ ] Tables/fields have sequential IDs starting from 1
- [ ] All tables have `<primary_key>` elements
- [ ] Every primary key field has index with `unique_keys="true"` and `type="7"`
- [ ] Text fields use type 10 (NOT type 11)
- [ ] UUID primary keys: `type="10"` + `autogenerate="true"` + `store_as_UUID="true"` + `not_null="true"`
- [ ] Integer primary keys: `type="4"` + `autosequence="true"` + `never_null="true"`
- [ ] Foreign key fields exist before relations, have indexes
- [ ] Vector fields: `type="21"` + `<field_extra class_id="4D.Vector"/>`
- [ ] XML is well-formed

## UUID vs Integer Primary Keys

**UUID (Modern)**: `type="10" autogenerate="true" store_as_UUID="true" not_null="true"`  
→ Globally unique, better for distributed systems, easier data merging

**Integer (Legacy)**: `type="4" autosequence="true" never_null="true"`  
→ Smaller storage, human-readable, simpler for small apps

Both require index with `unique_keys="true" type="7"`

## Tools and Tips

### Generate UUIDs
```bash
uuidgen
```

### Validate XML Structure
```bash
xmllint --noout catalog.4DCatalog
```

### Check for Duplicate UUIDs
```bash
grep -o 'uuid="[^"]*"' catalog.4DCatalog | sort | uniq -d
```

### Count Tables
```bash
grep -c '<table name=' catalog.4DCatalog
```

### Extract All Table Names
```bash
grep -o '<table name="[^"]*"' catalog.4DCatalog | sed 's/<table name="//;s/"//'
```
